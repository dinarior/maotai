# try rstiefel's optimization
library(rstiefel)
F2  = function(V){sum(diag(t(V)%*%B%*%V))/sum(diag(t(V)%*%A%*%V))} # top/bottom switch; can we speed up
dF2 = function(V){
aa = sum(diag(t(V)%*%A%*%V))
bb = sum(diag(t(V)%*%B%*%V))
t1 = 2*aa*(B%*%V) - 2*bb*(A%*%V)
t2 = aa^2
return(t1/t2)
}
st.V2 = optStiefel(F2,dF2, Vinit=rustiefel(p,mydim), method="curvilinear",
searchParams=list(rho1=0.1, rho2=0.9, tau=1),tol=1009*.Machine$double.eps)
st.val2 = sum(diag(t(st.V2)%*%A%*%st.V2))/sum(diag(t(st.V2)%*%B%*%st.V2))
st.val2
m3$tr.val
myval
library(maotai)
RSpectra::eigs()
help(eigs)
help(det)
A = matrix(rnorm(25),nrow=5)
A = A%*%t(A)
det(A)
determinant(A, logarithm=TRUE)
determinant(A, logarithm=FALSE)
k=NULL
length(k)
is.null(k)
help(rankMatrix)
A
as.integer(rankMatrix(x))
library(Matrix)
as.integer(rankMatrix(x))
as.integer(rankMatrix(A))
RSpectra::eigs(A, 1)
help(eigs)
RSpectra::eigs(A, 1, "SA")
RSpectra::eigs(A, 1, "SR")
RSpectra::eigs(A, 1, "SR")$values
eigen(A)$values
B = matrix(rnorm(25),nrow=5)
B
eigen(B)$values
det(B)
abs(eigen(B)$values)
library(maotai)
library(maotai)
library(maotai)
pdet(A)
pdet(A, k=4)
pdet(A, k=3)
library(maotai)
pdet(A, k=4)
library(maotai)
pdet(A, k=4)
A = cov(matrix(rnorm(3*5),ncol=5))
pdet(A)
rankMatrix(A)
pdet(A, k=2)
x = sqrt(-01)
x = sqrt(-1)
x
A
B
eigen(B)$values
real(eigen(B)$values)
as.real(eigen(B)$values)
help(real)
Re(eigen(B)$values)
library(maotai)
pdet(B)
det(B)
rankMatrix(B)
pdet(B, k=4)
library(maotai)
library(maotai)
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
h = 0.01
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xp[i,j] - h
dX[i,j] = (sum(diag(Xp))-sum(diag(Xm)))/(2*h)
}
}
dX
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xp[i,j] - h
dX[i,j] = (sum(diag(Xp))-sum(diag(Xm)))/(2*h)
}
}
dX
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xp[i,j] - h
dX[i,j] = (fX(Xp)-fX(Xm))/(2*h)
}
}
dX
t(X)
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xp[i,j] - h
dX[i,j] = (fX(Xp)-fX(X))/(h)
}
}
dX
t(X)
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xm[i,j] - h
dX[i,j] = (fX(Xp)-fX(Xm))/(2*h)
}
}
dX
t(X)
2*t(X)
library(maotai)
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xm[i,j] - h
dX[i,j] = (fX(Xp)-fX(Xm))/(2*h)
}
}
dX
mygradF(fX,X)
library(maotai)
mygradF(fX,X)
dX
t(X)
2*t(X)
n = 1:100
y = log(n)/n
plot(n,y)
library(maotai)
library(maotai)
## multiple sample
rm(list=ls())
load("/home/kisung/Desktop/test_HypDimRed/mnist.RData")
pixel = matrix(as.double(as.matrix(data$pixels)),ncol=ncol(data$pixels))
label = data$labels
# extract 1000 random samples
idx = sample(1:nrow(pixel), 1000)
subdat = pixel[idx,]
sublab = as.integer(label[idx])
# 1. LDA ------------------------------------------------------------------
library(maotai)
p       = ncol(subdat)
ulabel  = unique(sublab)
datlist = list()
for (i in 1:length(unique(sublab))){
datlist[[i]] = subdat[which(sublab==ulabel[i]),]
}
meancl = lapply(datlist, colMeans)
meangb = colMeans(subdat)
Sb = array(0,c(p,p))
Sw = array(0,c(p,p))
for (i in 1:length(unique(sublab))){
tgti  = datlist[[i]]
ni    = nrow(tgti)
xdiff = as.vector(meancl[[i]]-meangb)
Sw = Sw + (ni-1)*cov(tgti)
Sb = Sb + ni*outer(xdiff,xdiff)
}
W1 = trio(Sb,Sw,dim=2,method="2007Wang", maxiter=100, eps=1e-6)
library(maotai)
library(maotai)
library(maotai)
h = 0.001
X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xm[i,j] - h
dX[i,j] = (fX(Xp)-fX(Xm))/(2*h)
}
}
dX
library(maotai)
library(maotai)
n = 10
A = cov(matrix(rnorm(5*n),ncol=n))
k = as.double(Matrix::rankMatrix(A))
ntry = 20
del.vec = exp(-(1:ntry))
det.vec = rep(0,ntry)
for (i in 1:ntry){
del = del.vec[i]
det.vec[i] = det(A+del*diag(n))/(del^(n-k))
}
plot(1:ntry, det.vec, main=paste("true rank is ",k,"/",n,sep=""),"b")
abline(h=pdeterminant(A),col="red",lwd=1.2)
A
rankMatrix(A)
library(Matrix)
rankMatrix(A)
pdeterminant(A)
c(1)
library(maotai)
library(maotai)
library(maotai)
library(maotai)
help("pdeterminant")
library(maotai)
library(maotai)
help(pdeterminant)
library(maotai)
help("pdeterminant")
help("shortestpath")
library(igraph)
make_ring(5)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
library(igraph)
gA = graph_from_adjacency_matrix(A)
plot(gA)
plot(gA, main="ring graph")
sdA <- shortestpath(A)
library(maotai)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
# compute shortest-path
sdA <- shortestpath(A)
image(sdA)
image(sdA, pty="s")
sdA <- shortestpath(A)
image(sdA, main="shortest path length for ring graph")
# show the graph
library(igraph)
gA = graph_from_adjacency_matrix(A)
plot(gA, main="ring graph")
library(maotai)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
# compute shortest-path and show the matrix
sdA <- shortestpath(A)
image(sdA, main="shortest path length for ring graph")
library(maotai)
help(trio)
install.packages(c("callr", "curl", "devtools", "digest", "ellipsis", "htmlTable", "pkgconfig"))
library(maotai)
library(maotai)
library(maotai)
# simple test
p = 100
mydim = 10
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
library(geigen)
eigAB = eigen(solve(B,A)) ## geigen(B,A) # we need largest so be careful of the order
mylist = list()
V = eigAB$vectors[,1:mydim]; mylist$V = V
myval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V)); mylist$tr.val = myval
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m9 = trio(A,B,dim=mydim, method="2009Jia")
m7 = trio(A,B,dim=mydim, method="2007Wang")
m3 = trio(A,B,dim=mydim, method="2003Guo")
# try rstiefel's optimization
library(rstiefel)
f1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(-trA/trB)
}
df1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = -2*(A%*%w)*trB + trA*2*(B%*%w);
t2 = trB^2;
return(t1/t2)
}
f2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(trB/trA)
}
df2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = 2*trA*(B%*%w) - 2*trB*(A%*%w);
t2 = trA^2;
return(t1/t2)
}
V1 <- optStiefel(f1, df1, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
V2 <- optStiefel(f2, df2, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
print(sprintf("result of (2) inverse  : %f", 1/f2(V2)))
install.packages("rstiefel")
library(rstiefel)
# try rstiefel's optimization
library(rstiefel)
f1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(-trA/trB)
}
df1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = -2*(A%*%w)*trB + trA*2*(B%*%w);
t2 = trB^2;
return(t1/t2)
}
f2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(trB/trA)
}
df2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = 2*trA*(B%*%w) - 2*trB*(A%*%w);
t2 = trA^2;
return(t1/t2)
}
V1 <- optStiefel(f1, df1, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
V2 <- optStiefel(f2, df2, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
print(sprintf("result of (2) inverse  : %f", 1/f2(V2)))
myval
eigV  = eigAB$vectors[,1:mydim]
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
eigval
p = 25
mydim = 2
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
#  approximate solution via determinant ratio problem formulation
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
eigval
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m09 = trio(A,B,dim=mydim, method="2009Jia")
m07 = trio(A,B,dim=mydim, method="2007Wang")
m03 = trio(A,B,dim=mydim, method="2003Guo")
cat(paste("* approximation via det : ",eigval,sep=""))
m12$tr.val
p = 5
mydim = 2
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
#  approximate solution via determinant ratio problem formulation
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
#  solve using 4 algorithms
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m09 = trio(A,B,dim=mydim, method="2009Jia")
m07 = trio(A,B,dim=mydim, method="2007Wang")
m03 = trio(A,B,dim=mydim, method="2003Guo")
#  print the results
cat('* Evaluation of the cost function ')
cat(paste("* approx. via determinant : ",eigval,sep=""))
cat(paste("* trio by 2012Ngo         : ",m12$tr.val, sep=""))
cat(paste("* trio by 2009Jia         : ",m09$tr.val, sep=""))
cat(paste("* trio by 2007Wang        : ",m07$tr.val, sep=""))
cat(paste("* trio by 2003Guo         : ",m03$tr.val, sep=""))
library(maotai)
library(maotai)
library(maotai)
library(maotai)
devtools::document()
devtools::document()
library(maotai)
devtools::document()
library(maotai)
#  generate square matrices
A = matrix(rnorm(25),nrow=5); A = A%*%t(A)
X = matrix(rnorm(25),nrow=5)
Q = A%*%X + X%*%t(A)
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
#  generate square matrices
A = matrix(rnorm(25),nrow=5)
X = matrix(rnorm(25),nrow=5)
Q = A%*%X + X%*%t(A)
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
cat("* Experiment with Lyapunov Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
library(maotai)
library(maotai)
## simulated example
#  generate square matrices
A = matrix(rnorm(25),nrow=5)
X = matrix(rnorm(25),nrow=5)
B = matrix(rnorm(25),nrow=5)
C = A%*%X + X%*%B
#  solve using 'sylvester' function
solX = lyapunov(A,B,C)
cat("* Experiment with Sylvester Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
solX = sylvester(A,B,C)
cat("* Experiment with Sylvester Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
library(maotai)
library(maotai)
library(maotai)
pack <- "maotai"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
library(maotai)
pack <- "maotai"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
library(maotai)
library(Schur)
x
library(Matrix)
x = matrix(rnorm(25),nrow=5)
Schur(x)
xx = Schur(x)
xx$Q%*5xx$T - x
xx$Q%*%xx$T - x
Q = xx$Q
QQ = xx$Q
TT = xx$T
QQ%*%TT%*%t(QQ)
QQ%*%TT%*%t(QQ)-x
usethis::use_code_of_conduct()
usethis::use_travis()
usethis::use_travis()
library(maotai)
library(maotai)
usethis::use_news_md()
usethis::use_news_md()
help(maotai)
library(maotai)
library(maotai)
library(maotai)
library(maotai)
