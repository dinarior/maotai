X = matrix(rnorm(9),nrow=3)
X = X%*%t(X)
dX = array(0,c(3,3))
fX = function(x){return(sum(diag(x%*%x)))}
for (i in 1:3){
for (j in 1:3){
Xp = X
Xm = X
Xp[i,j] = Xp[i,j] + h
Xm[i,j] = Xm[i,j] - h
dX[i,j] = (fX(Xp)-fX(Xm))/(2*h)
}
}
dX
library(maotai)
library(maotai)
n = 10
A = cov(matrix(rnorm(5*n),ncol=n))
k = as.double(Matrix::rankMatrix(A))
ntry = 20
del.vec = exp(-(1:ntry))
det.vec = rep(0,ntry)
for (i in 1:ntry){
del = del.vec[i]
det.vec[i] = det(A+del*diag(n))/(del^(n-k))
}
plot(1:ntry, det.vec, main=paste("true rank is ",k,"/",n,sep=""),"b")
abline(h=pdeterminant(A),col="red",lwd=1.2)
A
rankMatrix(A)
library(Matrix)
rankMatrix(A)
pdeterminant(A)
c(1)
library(maotai)
library(maotai)
library(maotai)
library(maotai)
help("pdeterminant")
library(maotai)
library(maotai)
help(pdeterminant)
library(maotai)
help("pdeterminant")
help("shortestpath")
library(igraph)
make_ring(5)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
library(igraph)
gA = graph_from_adjacency_matrix(A)
plot(gA)
plot(gA, main="ring graph")
sdA <- shortestpath(A)
library(maotai)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
# compute shortest-path
sdA <- shortestpath(A)
image(sdA)
image(sdA, pty="s")
sdA <- shortestpath(A)
image(sdA, main="shortest path length for ring graph")
# show the graph
library(igraph)
gA = graph_from_adjacency_matrix(A)
plot(gA, main="ring graph")
library(maotai)
## simple example : a ring graph
#  edges exist for pairs
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
# compute shortest-path and show the matrix
sdA <- shortestpath(A)
image(sdA, main="shortest path length for ring graph")
library(maotai)
help(trio)
install.packages(c("callr", "curl", "devtools", "digest", "ellipsis", "htmlTable", "pkgconfig"))
library(maotai)
library(maotai)
library(maotai)
# simple test
p = 100
mydim = 10
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
library(geigen)
eigAB = eigen(solve(B,A)) ## geigen(B,A) # we need largest so be careful of the order
mylist = list()
V = eigAB$vectors[,1:mydim]; mylist$V = V
myval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V)); mylist$tr.val = myval
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m9 = trio(A,B,dim=mydim, method="2009Jia")
m7 = trio(A,B,dim=mydim, method="2007Wang")
m3 = trio(A,B,dim=mydim, method="2003Guo")
# try rstiefel's optimization
library(rstiefel)
f1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(-trA/trB)
}
df1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = -2*(A%*%w)*trB + trA*2*(B%*%w);
t2 = trB^2;
return(t1/t2)
}
f2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(trB/trA)
}
df2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = 2*trA*(B%*%w) - 2*trB*(A%*%w);
t2 = trA^2;
return(t1/t2)
}
V1 <- optStiefel(f1, df1, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
V2 <- optStiefel(f2, df2, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
print(sprintf("result of (2) inverse  : %f", 1/f2(V2)))
install.packages("rstiefel")
library(rstiefel)
# try rstiefel's optimization
library(rstiefel)
f1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(-trA/trB)
}
df1 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = -2*(A%*%w)*trB + trA*2*(B%*%w);
t2 = trB^2;
return(t1/t2)
}
f2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
return(trB/trA)
}
df2 = function(w){
trA = sum(diag(t(w)%*%A%*%w)); trB = sum(diag(t(w)%*%B%*%w));
t1 = 2*trA*(B%*%w) - 2*trB*(A%*%w);
t2 = trA^2;
return(t1/t2)
}
V1 <- optStiefel(f1, df1, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
V2 <- optStiefel(f2, df2, Vinit=rustiefel(p,mydim), maxIters = 999, tol=1e-10, verbose=TRUE)
print(sprintf("result of (2) inverse  : %f", 1/f2(V2)))
myval
eigV  = eigAB$vectors[,1:mydim]
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
eigval
p = 25
mydim = 2
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
#  approximate solution via determinant ratio problem formulation
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
eigval
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m09 = trio(A,B,dim=mydim, method="2009Jia")
m07 = trio(A,B,dim=mydim, method="2007Wang")
m03 = trio(A,B,dim=mydim, method="2003Guo")
cat(paste("* approximation via det : ",eigval,sep=""))
m12$tr.val
p = 5
mydim = 2
A = matrix(rnorm(p^2),nrow=p); A=A%*%t(A)
B = matrix(runif(p^2),nrow=p); B=B%*%t(B)
C = diag(p)
#  approximate solution via determinant ratio problem formulation
eigAB  = eigen(solve(B,A))
V      = eigAB$vectors[,1:mydim]
eigval = sum(diag(t(V)%*%A%*%V))/sum(diag(t(V)%*%B%*%V))
#  solve using 4 algorithms
m12 = trio(A,B,dim=mydim, method="2012Ngo")
m09 = trio(A,B,dim=mydim, method="2009Jia")
m07 = trio(A,B,dim=mydim, method="2007Wang")
m03 = trio(A,B,dim=mydim, method="2003Guo")
#  print the results
cat('* Evaluation of the cost function ')
cat(paste("* approx. via determinant : ",eigval,sep=""))
cat(paste("* trio by 2012Ngo         : ",m12$tr.val, sep=""))
cat(paste("* trio by 2009Jia         : ",m09$tr.val, sep=""))
cat(paste("* trio by 2007Wang        : ",m07$tr.val, sep=""))
cat(paste("* trio by 2003Guo         : ",m03$tr.val, sep=""))
library(maotai)
library(maotai)
library(maotai)
library(maotai)
devtools::document()
devtools::document()
library(maotai)
devtools::document()
library(maotai)
#  generate square matrices
A = matrix(rnorm(25),nrow=5); A = A%*%t(A)
X = matrix(rnorm(25),nrow=5)
Q = A%*%X + X%*%t(A)
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
#  generate square matrices
A = matrix(rnorm(25),nrow=5)
X = matrix(rnorm(25),nrow=5)
Q = A%*%X + X%*%t(A)
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
#  solve using 'lyapunov' function
solX = lyapunov(A,Q)
cat("* Experiment with Lyapunov Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
library(maotai)
library(maotai)
## simulated example
#  generate square matrices
A = matrix(rnorm(25),nrow=5)
X = matrix(rnorm(25),nrow=5)
B = matrix(rnorm(25),nrow=5)
C = A%*%X + X%*%B
#  solve using 'sylvester' function
solX = lyapunov(A,B,C)
cat("* Experiment with Sylvester Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
solX = sylvester(A,B,C)
cat("* Experiment with Sylvester Solver")
cat(paste("* Absolute Error  : ",norm(solX-X,"f"),sep=""))
cat(paste("* Relative Error  : ",norm(solX-X,"f")/norm(X,"f"),sep=""))
library(maotai)
library(maotai)
library(maotai)
pack <- "maotai"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
library(maotai)
pack <- "maotai"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
library(maotai)
library(Schur)
x
library(Matrix)
x = matrix(rnorm(25),nrow=5)
Schur(x)
xx = Schur(x)
xx$Q%*5xx$T - x
xx$Q%*%xx$T - x
Q = xx$Q
QQ = xx$Q
TT = xx$T
QQ%*%TT%*%t(QQ)
QQ%*%TT%*%t(QQ)-x
usethis::use_code_of_conduct()
usethis::use_travis()
usethis::use_travis()
library(maotai)
library(maotai)
usethis::use_news_md()
usethis::use_news_md()
help(maotai)
library(maotai)
library(maotai)
library(maotai)
library(maotai)
library(maotai)
help("cmdscale")
require(graphics)
loc <- cmdscale(eurodist)
x <- loc[, 1]
y <- -loc[, 2] # reflect so North is at the top
loc
xx = eurodist
xx
xx = as.matrix(xx)
xx
dmat = xx
embedded = cmdscale(dmat, k=nrow(dmat)-1)
dmat
eigen(dmat)$values
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
H = -(J%*%dmat%*%J)/2.0
eigen(H)$values
help(eigen)
base::eigen(H, symmetric = TRUE, only.values = TRUE)
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
H = -(J%*%dmat%*%J)/2.0
kk = max(length(which(base::eigen(H, symmetric = TRUE, only.values = TRUE)$values>sqrt(.Machine$double.eps))), 2)
kk
#' @keywords internal
#' @noRd
aux_pseudomean_dim <- function(dmat){
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
H = -(J%*%dmat%*%J)/2.0
kk = max(length(which(base::eigen(H, symmetric = TRUE, only.values = TRUE)$values>sqrt(.Machine$double.eps))), 2)
return(kk)
}
# we need embedding .. umm .. dimension .. dmat = (n x n)
embedded = stats::cmdscale(dmat, k=aux_pseudomean_dim(dmat)) # embedded
dmat
eigen(dmat)$values
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
H = -(J%*%(dmat^2)%*%J)/2.0
kk = max(length(which(base::eigen(H, symmetric = TRUE, only.values = TRUE)$values>sqrt(.Machine$double.eps))), 2)
kk
kk = max(length(which(base::eigen(H, symmetric = TRUE, only.values = TRUE)$values>sqrt(.Machine$double.eps)))-1, 2)
#' @keywords internal
#' @noRd
aux_pseudomean_auto <- function(dmat){
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
H = -(J%*%(dmat^2)%*%J)/2.0
kk = max(length(which(base::eigen(H, symmetric = TRUE, only.values = TRUE)$values>sqrt(.Machine$double.eps)))-1, 2)
return(kk)
}
# we need embedding .. umm .. dimension .. dmat = (n x n)
embedded = stats::cmdscale(dmat, k=aux_pseudomean_dim(dmat)) # embedded
# we need embedding .. umm .. dimension .. dmat = (n x n)
embedded = stats::cmdscale(dmat, k=aux_pseudomean_auto(dmat)) # embedded
dim(embedded)
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
B = -(J%*%(dmat^2)%*%J)/2.0
eigB = base::eigen(B, symmetric = TRUE)
eigB$vectors
eigB$values
#' @keywords internal
#' @noRd
aux_pseudomean_auto <- function(dmat){ # only positive eigenvalues' part
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
B = -(J%*%(dmat^2)%*%J)/2.0
eigB = base::eigen(B, symmetric = TRUE) # decreasing order
m = max(length(which(eigB$values > 0)),2)
X = (eigB$vectors[,1:m])%*%(base::diag(sqrt(eigB$values[1:m])))
return(X)
}
hey = aux_pseudomean_auto(dmat)
dim(hey)
hey
plot(hey[,1],hey[,2])
hh = cmdscale(dmat, k=2)
plot(hh[,1], hh[,2])
# we need embedding .. umm .. automatic dimension selection
embedded = aux_pseudomean_auto(dmat)
# centering based on other points
emcenter = as.vector(base::colMeans(embedded[2:nrow(embedded),]))
emcenter
x = rnorm(3)
matrix(rep(x,3),ncol=3,byrow=TRUE)
xx = matrix(rep(x,3),ncol=3,byrow=TRUE)
lower.tri(xx)
xx[lower.tri(xx)]
xx
xx^2
xx*(xx^2)
xx^3
dmat
help(lower.tri)
library(maotai)
#' @keywords internal
#' @noRd
aux_pseudomean_auto <- function(dmat){ # only positive eigenvalues' part
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
B = -(J%*%(dmat^2)%*%J)/2.0
eigB = base::eigen(B, symmetric = TRUE) # decreasing order
m = max(length(which(eigB$values > 0)),2)
X = (eigB$vectors[,1:m])%*%(base::diag(sqrt(eigB$values[1:m])))
return(X)
}
# (2) aux_pseudomean ------------------------------------------------------
#' @keywords internal
#' @noRd
aux_pseudomean <- function(dmat){
# we need embedding .. umm .. automatic dimension selection
embedded = aux_pseudomean_auto(dmat)
n = nrow(embedded)
p = ncol(embedded)
# centering based on other points
emcenter = as.vector(base::colMeans(embedded[2:n,]))
embednew = embedded - matrix(rep(emcenter,n), ncol=p, byrow=TRUE)
# compute scalar
d1mat = dmat[2:n,2:n]                          # d(x,y)
d2mat = as.matrix(stats::dist(embednew[2:n,])) # ||x-y||
d12mat = (d1mat*d2mat)
d22mat = (d2mat^2)
dlower = base::lower.tri(d12mat)
cstar =sum(d12mat[dlower])/sum(d22mat[dlower])
# update embednew and compute
erow1 = c*as.vector(embednew[1,])
return(sqrt(sum(erow1^2)))
}
x = rnorm(5, mean=3)
y = matrix(rnorm(10*5),ncol=5)
dmat = as.matrix(dist(rbind(x,y)))
aux_pseudomean(dmat)
# we need embedding .. umm .. automatic dimension selection
embedded = aux_pseudomean_auto(dmat)
embedded
# we need embedding .. umm .. automatic dimension selection
embedded = aux_pseudomean_auto(dmat)
n = nrow(embedded)
p = ncol(embedded)
# centering based on other points
emcenter = as.vector(base::colMeans(embedded[2:n,]))
embednew = embedded - matrix(rep(emcenter,n), ncol=p, byrow=TRUE)
# compute scalar
d1mat = dmat[2:n,2:n]                          # d(x,y)
d2mat = as.matrix(stats::dist(embednew[2:n,])) # ||x-y||
d12mat = (d1mat*d2mat)
d22mat = (d2mat^2)
dlower = base::lower.tri(d12mat)
cstar =sum(d12mat[dlower])/sum(d22mat[dlower])
# update embednew and compute
erow1 = c*as.vector(embednew[1,])
embednew
# update embednew and compute
erow1 = cstar*as.vector(embednew[1,])
return(sqrt(sum(erow1^2)))
dlower = base::lower.tri(d12mat)
cstar =sum(d12mat[dlower])/sum(d22mat[dlower])
# update embednew and compute
erow1 = cstar*as.vector(embednew[1,])
sqrt(sum(erow1^2))
sqrt(sum(x^2))
rm(list=ls())
# personal test
x = rnorm(5, mean=3)
y = matrix(rnorm(10*5),ncol=5)
dmat = as.matrix(dist(rbind(x,y)))
val.alg = aux_pseudomean(dmat)
#' @keywords internal
#' @noRd
aux_pseudomean_auto <- function(dmat){ # only positive eigenvalues' part
n = nrow(dmat)
J = diag(rep(1,n))-(1/n)*outer(rep(1,n),rep(1,n))
B = -(J%*%(dmat^2)%*%J)/2.0
eigB = base::eigen(B, symmetric = TRUE) # decreasing order
m = max(length(which(eigB$values > 0)),2)
X = (eigB$vectors[,1:m])%*%(base::diag(sqrt(eigB$values[1:m])))
return(X)
}
# (2) aux_pseudomean ------------------------------------------------------
#' @keywords internal
#' @noRd
aux_pseudomean <- function(dmat){
# we need embedding .. umm .. automatic dimension selection
embedded = aux_pseudomean_auto(dmat)
n = nrow(embedded)
p = ncol(embedded)
# centering based on other points
emcenter = as.vector(base::colMeans(embedded[2:n,]))
embednew = embedded - matrix(rep(emcenter,n), ncol=p, byrow=TRUE)
# compute scalar
d1mat = dmat[2:n,2:n]                          # d(x,y)
d2mat = as.matrix(stats::dist(embednew[2:n,])) # ||x-y||
d12mat = (d1mat*d2mat)
d22mat = (d2mat^2)
dlower = base::lower.tri(d12mat)
cstar =sum(d12mat[dlower])/sum(d22mat[dlower])
# update embednew and compute
erow1 = cstar*as.vector(embednew[1,])
return(sqrt(sum(erow1^2)))
}
x = rnorm(5, mean=3)
y = matrix(rnorm(10*5),ncol=5)
dmat = as.matrix(dist(rbind(x,y)))
val.alg = aux_pseudomean(dmat)
val.true = sqrt(sum((x-as.vector(colMeans(y)))^2))
val.alg
val.true
rm(list=ls())
library(maotai)
library(maotai)
library(maotai)
library(maotai)
